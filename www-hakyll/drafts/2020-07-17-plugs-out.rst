---
title: Plugs Out
subtitle: Type checker plugins without the type checking.
slug: Type checker plugins without the type checking.
tags: haskell, type checker plugins
---
When getting ready to launch a human-rated spacecraft, one of the steps is
the plugs-out test. Can the the spacecraft function on its own without power
or fuel from all cables and umbilicals?

While debugging plugins, I've found out a thing or two along the way by
adding tracing and changing how I wire up the plugin. I've collected snippets
of that work into a package, `ghc-plugs-out`_, a kind of plugs-out test for
GHC type checker plugins. It is the first multiple library package I've put
together[#]_. Each test suite in the package demonstrates something I've learnt.

Wiring Diagram
--------------
There's more than one way to wire up a plugin; with a pragma, with an option
or both. If your plugin is impure, it's going to force an extra recompilation
to boot. It is recommended to wire up plugins with pragmas for only the
modules that need them. It is probably fine to use options if all your
modules need a plugin. If you mix and match both ways of doing the wiring
you'll end up with two instances of the plugin in the compilation.

.. code-block:: pre

  > cabal build test-wireup-pure-by-pragma
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)

  > cabal build test-wireup-pure-by-option
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)

  > cabal build test-wireup-pure-by-both
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)
  >>> GHC-TcPlugin-CallCount (1)

  > cabal build test-wireup-impure-by-pragma
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)
  [1 of 1] Compiling Main [Impure plugin forced recompilation]
  >>> GHC-TcPlugin-CallCount (1)

  > cabal build test-wireup-impure-by-option
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)
  [1 of 1] Compiling Main [Impure plugin forced recompilation]
  >>> GHC-TcPlugin-CallCount (1)

  > cabal build test-wireup-impure-by-both
  [1 of 1] Compiling Main
  >>> GHC-TcPlugin-CallCount (1)
  >>> GHC-TcPlugin-CallCount (1)
  [1 of 1] Compiling Main [Impure plugin forced recompilation]
  >>> GHC-TcPlugin-CallCount (1)
  >>> GHC-TcPlugin-CallCount (1)

Undefined is not a Function
---------------------------

If your plugin behaves badly it is going to hurt. GHC panics when any one of
the functions required of a type checker plugin is implemented undefined.

.. code-block:: haskell

    plugin :: Plugin
    plugin = mkPureTcPlugin undefSolve

    undefSolve :: TcPlugin
    undefSolve = noOp { tcPluginSolve = \_ _ _ _ -> undefined }

    noOp :: TcPlugin
    noOp =
        TcPlugin
            { tcPluginInit = return ()
            , tcPluginSolve = \_ _ _ _ -> return $ TcPluginOk [] []
            , tcPluginStop = const $ return ()
            }

    mkPureTcPlugin :: TcPlugin -> Plugin
    mkPureTcPlugin p =
        defaultPlugin
            { tcPlugin = const $ Just p
            , pluginRecompile = purePlugin
            }

.. code-block:: pre

    > cabal build test-undefined-solve
    [1 of 1] Compiling Undefined.Solve.Plugin
    [1 of 1] Compiling Main
    ghc: panic! (the 'impossible' happened)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug

I would have liked to use record update syntax for undefSolve as shown above
but this is not yet possible [#]_ with GHC when the data type has an
existential qualifier and that is how TcPlugin is defined [#]_.

.. code-block:: haskell

    data TcPlugin = forall s. TcPlugin
        { tcPluginInit  :: TcPluginM s
        -- ^ Initialize plugin, when entering type-checker.
        , tcPluginSolve :: s -> TcPluginSolver
        -- ^ Solve some constraints.
        -- TODO: WRITE MORE DETAILS ON HOW THIS WORKS.
        , tcPluginStop  :: s -> TcPluginM ()
        -- ^ Clean up after the plugin, when exiting the type-checker.
        }

The plugin is of course called on by GHC to resolve constraints. Some
functions need solving and others don't. Getting an ``a`` from ``undefined``, it's needed.

.. code-block:: haskell

    {-# OPTIONS_GHC -fplugin Undefined.Solve.Plugin #-}
    module Main where

    main :: IO a
    main = undefined

Going from ``()`` to ``()`` needs no further resolution. GHC can handle this
by itself. The ``test-undefined-*-carefree`` test suites have these mains.
The ones without carefree in their name don't. They have the ``a`` from
``undefined`` mains.

.. code-block:: haskell

    {-# OPTIONS_GHC -fplugin Undefined.Solve.Plugin #-}
    module Main where

    main :: IO ()
    main = return ()

  So we've seen that a typechecker plugin's solve function may be called but
  its init and stop functions are always called.

.. code-block:: ascii

  +-------------------------------+------------+
  | Test Suite                    | GHC Panics |
  +===============================+============+
  | test-undefined-init           |     x      |
  +-------------------------------+------------+
  | test-undefined-init-carefree  |     x      |
  +-------------------------------+------------+
  | test-undefined-solve          |     x      |
  +-------------------------------+------------+
  | test-undefined-solve-carefree |            |
  +-------------------------------+------------+
  | test-undefined-stop           |     x      |
  +-------------------------------+------------+
  | test-undefined-stop-carefree  |     x      |
  +-------------------------------+------------+


.. _ghc-plugs-out: https://github.com/BlockScope/ghc-plugs-out

.. _ghc-2595: https://gitlab.haskell.org/ghc/ghc/issues/2595

.. _fgaz-GSoC-2018: https://fgaz.me/posts/2019-11-14-cabal-multiple-libraries/

.. [#] Multiple libraries were added to cabal 3.0, see fgaz-GSoC-2018_.
.. [#] The error if you try is "Record update for insufficiently polymorphic field", see ghc-2595_.
.. [#] These field haddock comments are verbatim from the GHC source.
       
